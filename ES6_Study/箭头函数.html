<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        //ES6允许使用箭头 => 定义函数
        //声明一个函数
        // let fn = function () {

        // }
        let fn = (a, b) => {
            return a + b;
        }
        //调用函数
        // let result = fn(1, 2);
        // console.log(result);

        //1、箭头函数中的this是静态的，this始终指向函数声明时所在作用域下的this的值，
        //箭头函数的this总是指向最近的外层作用域中的this所指对象
        function getName () {
            console.log(this.name);
        }
        let getName2 = () => {//声明时指向window
            console.log(this.name);
        }
        window.name = 'cjx';
        const school = {
            name: 'ccc'
        }
        getName();//这两个的结果都是cjx，因为相当于window.getName(),window.getName2()
        getName2();

        //这时利用call函数，call函数可以改变函数内部的this值,让它们指向school对象
        //此时，第一个输出ccc,而第二个仍然输出cjx，证明箭头函数的this始终指向函数声明时所在
        //作用域下的this的值，是静态的
        getName.call(school);
        getName2.call(school);

        //2、不能作为构造函数实例化对象
        let Person = (name, age) => {
            this.name = name;
            this.age = age;
        }
        // let me = new Person();//报错

        //3、不能使用arguments变量
        // let fn1 = () => {
        //     console.log(arguments);
        // }
        // fn1(1,2,3);

        //4、箭头函数的简写
        //（1）省略小括号：当形参有且仅有一个时
        // let fn1 = (n) => {
        //     return n + n;
        // }
        //上面的可以简写为:
        // let fn1 = n => {
        //     return n + n;
        // }
        //（2）省略花括号：当代码体只有一条语句时,并且如果有return语句，此时return必须省略
        //而且语句的执行结果就是函数的返回值
        //let fn1 = (n) => {
            // return n * n;
        // }
        //上面的可以简写为:
        let fn1 = n => n * n;
        console.log(fn1(8));
    </script>
</body>
</html>